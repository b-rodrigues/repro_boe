{
  "hash": "64827c2ed28f59cda0a9614321349b78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"What’s up with reproducibility in R?\"\nauthor: \"Bruno Rodrigues\"\nformat:\n  revealjs:\n    embed-resources: true\n    slide-number: true\n    theme: solarized\n    incremental: true\n  pptx:\n    freeze: true\nexecute:\n  echo: true\n---\n\n\n\n\n## Intro: Who am I\n\nBruno Rodrigues, head of the statistics and data strategy departments at the Ministry of Research and Higher education in Luxembourg\n\nSlides available online at [https://is.gd/repro_boe](https://is.gd/repro_boe)\n\nCode available at: [https://github.com/b-rodrigues/repro_boe](https://github.com/b-rodrigues/repro_boe)\n\n## Thing I want to talk about\n\n-   Identify *what* must be managed for reproducibility\n-   Learn about the following tools to turn your projects reproducible\n    * {renv}, Docker and Nix\n\n-   What I will *not* discuss (but is very useful!):\n    * FP, Git, Documenting, testing and packaging code, build automation with {targets}\n\n## What I mean by *reproducibility*\n\n-   Ability to recover *exactly* the same results from an analysis\n-   Why would you want that?\n-   Auditing purposes\n-   Update of data (only impact must be from data update)\n-   Reproducibility as a cornerstone of science\n-   (Work on an immutable dev environment)\n. . .\n-   \"But if I have the original script and data, what's the problem?\"\n\n## A typical project’s setup\n\n- Our project: housing in Luxembourg\n- Data to analyse: `vente-maison-2010-2021.xlsx` in the `data` folder\n- 2 scripts to analyse data (in the `scripts/project_start` folder):\n  1. One to scrape the Excel file [save_data.R](https://raw.githubusercontent.com/b-rodrigues/rap4all/master/scripts/save_data.R)\n  2. One to analyse the data  [analysis.R](https://raw.githubusercontent.com/b-rodrigues/rap4all/master/scripts/analysis.R)\n\n## Project start - What's wrong with these scripts?\n\n- The first two scripts -> script-based workflow\n- Just a long series of calls\n- No functions\n  * difficult to re-use!\n  * difficult to test!\n  * difficult to parallelise!\n  * lots of repetition!\n- Also: usually we want a report not just a script\n- No record of package, nor R, versions used\n\n## Turning our scripts reproducible\n\nWe need to answer these questions\n\n. . .\n\n1. How easy would it be for someone else to rerun the analysis?\n2. How easy would it be to update the project?\n3. How easy would it be to reuse this code for another project?\n4. What guarantee do we have that the output is stable through time?\n\n## Reproducibility is on a continuum (1/2)\n\nHere are the 4 main things influencing an analysis' reproducibility:\n\n-   Version of R used\n-   Versions of packages used\n-   Operating system\n-   Hardware\n\n## Reproducibility is on a continuum (2/2)\n\n![](images/repro_spectrum.png){fig-align=\"center\"}\n\nSource: Peng, Roger D. 2011. \"Reproducible Research in Computational Science.\" Science 334 (6060): 1226--27\n\n## Recording packages and R version used with renv\n\nCreate a `renv.lock` file in 2 steps!\n\n- Open an R session in the folder containing the scripts\n- Run `renv::init()` and check the folder for `renv.lock`\n\n. . .\n\n(`renv::init()` will take some time to run the first time)\n\n## What an `renv.lock` file looks like\n\n. . .\n\n```\n{\n\"R\": {\n  \"Version\": \"4.2.2\",\n  \"Repositories\": [\n  {\n   \"Name\": \"CRAN\",\n   \"URL\": \"https://packagemanager.rstudio.com/all/latest\"\n  }\n  ]\n},\n\"Packages\": {\n  \"MASS\": {\n    \"Package\": \"MASS\",\n    \"Version\": \"7.3-58.1\",\n    \"Source\": \"Repository\",\n    \"Repository\": \"CRAN\",\n    \"Hash\": \"762e1804143a332333c054759f89a706\",\n    \"Requirements\": []\n  },\n  \"Matrix\": {\n    \"Package\": \"Matrix\",\n    \"Version\": \"1.5-1\",\n    \"Source\": \"Repository\",\n    \"Repository\": \"CRAN\",\n    \"Hash\": \"539dc0c0c05636812f1080f473d2c177\",\n    \"Requirements\": [\n      \"lattice\"\n    ]\n\n    ***and many more packages***\n```\n\n## Restoring a library using an `renv.lock` file\n\n- `renv.lock` file not just a record\n- Can be used to restore as well!\n- Run `renv::restore()`\n\n## `{renv}` conclusion\n\nShortcomings:\n\n. . .\n\n1. Records, but does not restore the version of R\n2. Installation of old packages can fail (due to missing OS-dependencies)\n\n. . .\n\nbut... :\n\n. . .\n\n1. Generating a `renv.lock` file is \"free\"\n2. Provides a blueprint for dockerizing our pipeline\n3. Creates a project-specific library (no interferences)\n\n## Going further with Docker: handling R and system-level dependencies\n\n- Docker is a containerisation tool that you install on your computer\n- Docker allows you to build *images* and run *containers* (a container is an instance of an image)\n- Docker images:\n    1. contain all the software and code needed for your project\n    2. are immutable (cannot be changed at run-time)\n    3. can be shared on- and offline\n\n## \"Hello, Docker!\"\n\n- Start by creating a so-called Dockerfile \n- Dockerfile = recipe for an image, starts off an existing **base image**\n- Build the image: `docker build -t hello .`\n- Run a container: `docker run --rm --name hello_container hello`\n- `--rm`: remove the container after running\n- `--name some_name`: name your container `some_name`\n\n## Without Docker\n\n![](images/without_docker.png){fig-align=\"center\"}\n\n## With Docker\n\n![](images/with_docker.png){fig-align=\"center\"}\n\n## Dockerizing a project (1/3)\n\n- At image build-time:\n  1. install R (or use an image that ships R)\n  2. install packages (using our `renv.lock` file)\n  3. copy all scripts to the image\n  4. run the analysis using `targets::tar_make()`\n\n- At container run-time:\n  1. copy the outputs of the analysis from the container to your computer\n  2. possible to \"log-in\" into a running container to inspect code and outputs\n\n## Dockerizing a project (2/3)\n\n- The completed and built image can be shared, or just the Dockerfile (and users can then rebuild the image)\n- The outputs will always stay the same!\n- Working interactively using Docker can be challenging though\n\n## Dockerizing a project (3/3)\n\n- But! Image build process not reproducible per se, only running containers is\n- YOU need to make sure build process is reproducible (or store the built images)\n  1. Need to fix version of R\n  2. Base image layer becomes unsupported at some point\n\n## The Rocker project\n\n- It is possible to build new images from other images\n- The Rocker project provides many images with R, RStudio, Shiny, and other packages pre-installed\n- I recommend the [\"r-ver\"](https://rocker-project.org/images/versioned/r-ver.html) images, specifically made for reproducibility\n\n## Docker: a panacea?\n\n- Docker is very useful and widely used\n- But the entry cost is high (familiarity with Linux is recommended)\n- Single point of failure (what happens if Docker gets bought, abandoned, etc? **quite unlikely though**)\n- Not actually dealing with reproducibility per se, we're \"abusing\" Docker in a way\n\n## The Nix package manager (1/2)\n\nPackage manager: tool to install and manage *packages*\n\nPackage: any piece of software (not just R packages)\n\nA popular package manager:\n\n. . .\n\n![Google Play Store](images/play_store.png)\n\n## The Nix package manager (2/2)\n\n- Reproducibility: R, R packages and other dependencies must be managed\n- Nix is a package manager actually focused on reproducible builds\n- Nix deals with everything, with one single text file (called a Nix expression)!\n- These Nix expressions *always* build the exact same output\n\n## A basic Nix expression (1/6)\n\n```\nlet\n  pkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n  system_packages = builtins.attrValues {\n    inherit (pkgs) R ;\n  };\nin\n  pkgs.mkShell {\n    buildInputs = [ system_packages ];\n    shellHook = \"R --vanilla\";\n  }\n```\n\nThere's a lot to discuss here!\n\n## A basic Nix expression (2/6)\n\n- Written in the Nix language (not discussed)\n- Defines the repository to use (with a fixed revision)\n- Lists packages to install\n- Defines the output: a development shell\n\n## A basic Nix expression (3/6)\n\n- Software for Nix is defined as a mono-repository of tens of thousands of expressions on Github\n- Github: we can use any commit to pin package versions for reproducibility!\n- For example, the following commit installs R 4.3.1 and associated packages:\n\n. . .\n\n```\npkgs = import (fetchTarball \"https://github.com/NixOS/nixpkgs/archive/976fa3369d722e76f37c77493d99829540d43845.tar.gz\") {};\n```\n\n- Let's take a look at the [repository](https://github.com/NixOS/nixpkgs)...\n\n## A basic Nix expression (4/6)\n\n- `system_packages`: a variable that lists software to install\n- In this case, only R:\n\n. . .\n\n```\nsystem_packages = builtins.attrValues {\n  inherit (pkgs) R ;\n};\n```\n\n## A basic Nix expression (5/6)\n\n- Finally, we define a shell:\n\n. . .\n\n```\npkgs.mkShell {\n  buildInputs = [ system_packages ];\n  shellHook = \"R --vanilla\";\n}\n```\n\n. . .\n\n- This shell will come with the software defined in `system_packages` (`buildInputs`)\n- And launch `R --vanilla` when started (`shellHook`)\n\n## A basic Nix expression (6/6)\n\n- Writing these expressions requires learning a new language\n- While incredibly powerful, if all we want are per-project reproducible dev shells...\n- ...then `{rix}` will help!\n\n## Nix expressions\n\n- Nix expressions can be used to install software\n- But we will use them to build per-project development shells\n- We will include R, LaTeX packages, or Quarto, Python, Julia....\n- Nix takes care of installing every dependency down to the compiler!\n\n## CRAN and Bioconductor\n\n- CRAN is the repository of R packages to extend the language\n- As of writing, +20000 packages available\n- Biocondcutor: repository with a focus on Bioinformatics: +2000 more packages\n- Almost all available through `nixpkgs` in the `rPackages` set!\n- Find packages [here](https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=dplyr)\n\n## rix: reproducible development environments with Nix (1/5)\n\n- `{rix}` ([website](https://docs.ropensci.org/rix/)) makes writing Nix expression easy!\n- Simply use the provided `rix()` function:\n\n. . .\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rix)\n\nrix(r_ver = \"4.3.1\",\n    #date = \"2025-01-27\", <- a date also works\n    r_pkgs = c(\"dplyr\", \"ggplot2\"),\n    system_pkgs = NULL,\n    git_pkgs = NULL,\n    tex_pkgs = NULL,\n    ide = \"code\",\n    project_path = \".\")\n```\n:::\n\n\n\n\n## rix: reproducible development environments with Nix (2/5)\n\n- `renv.lock` files can also be used as starting points:\n\n. . . \n\n```\nlibrary(rix)\n\nrenv2nix(\n  renv_lock_path = \"path/to/original/renv_project/renv.lock\",\n  project_path = \"path/to/rix_project\",\n  override_r_ver = \"4.4.1\" # <- optional\n)\n\n```\n\n## rix: reproducible development environments with Nix (3/5)\n\n- List required R version and packages\n- Optionally: more system packages, packages hosted on Github, or LaTeX packages\n- Optionally: an IDE (Rstudio, Radian, VS Code or \"other\")\n- Work interactively in an isolated, project-specific and reproducible environment!\n\n## rix: reproducible development environments with Nix (4/5)\n\n- `rix::rix()` generates a `default.nix` file\n- Build expressions using `nix-build` (in terminal) or `rix::nix_build()` from R \n- \"Drop\" into the development environment using `nix-shell`\n- Expressions can be generated even without Nix installed\n\n## rix: reproducible development environments with Nix (5/5)\n\n- Can install specific versions of packages (write `\"dplyr@1.0.0\"`)\n- Can install packages hosted on Github\n- Many vignettes to get you started! [See here](https://docs.ropensci.org/rix/articles/)\n\n. . .\n\nLet's check out `scripts/nix_expressions/rix_intro/`\n\n## Non-interactive use\n\n- `{rix}` makes it easy to run pipelines in the right environment\n- (Little side note: the best tool to build pipelines in R is `{targets}`)\n- See `scripts/nix_expressions/nix_targets_pipeline`\n- Can also run the pipeline like so:\n\n. . .\n\n```\ncd /absolute/path/to/pipeline/ && nix-shell default.nix --run \"Rscript -e 'targets::tar_make()'\"\n```\n\n## Nix and Github Actions: running pipelines\n\n- Possible to easily run a `{targets}` pipeline on Github actions\n- Simply run `rix::tar_nix_ga()` to generate the required files\n- Commit and push, and watch the actions run!\n- See [here](https://github.com/b-rodrigues/nix_targets_pipeline/tree/master).\n\n## Nix and Github Actions: writing papers\n\n- Easy collaboration on papers as well\n- See [here](https://github.com/b-rodrigues/rix_paper/tree/master)\n- Just focus on writing!\n\n## Conclusion\n\n- Very vast and complex topic!\n- At the very least, generate an `renv.lock` file\n- Always possible to rebuild a Docker image in the future (either you, or someone else!)\n- Consider using `{targets}`: not only good for reproducibility, but also an amazing tool all around\n- Long-term reproducibility: must use Docker or Nix (better: both!) and maintenance effort is required as well\n\n## The end\n\nContact me if you have questions:\n\n- bruno@brodrigues.co\n- Twitter: @brodriguesco\n- Mastodon: @brodriguesco@fosstodon.org\n- Blog: www.brodrigues.co\n- Book: www.raps-with-r.dev\n- rix: https://docs.ropensci.org/rix\n\n. . .\n\nThank you!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}